---
title: "CAP Theorem"
date: 2023-03-23T17:19:15+08:00
---

== CAP原理

CAP原理（CAP Theorem）是指在一个分布式系统中，Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性）三个特性中，最多只能同时满足其中两个，无法同时满足所有三个特性。

* Consistency（一致性）指的是多个节点的数据在同一时刻是否相同。当一个节点更新了数据后，其他节点是否可以立即读取到更新后的数据。

* Availability（可用性）指的是在分布式系统中，节点之间出现故障时，系统是否可以继续提供服务。即使出现节点故障，其他节点是否可以继续处理请求。

* Partition Tolerance（分区容错性）指的是在分布式系统中，网络出现故障或者消息丢失时，系统是否可以继续工作。即使出现了分区（网络分割）的情况，系统是否仍然可以处理请求。

在分布式系统中，分区容错性是必须满足的特性，因为在分布式系统中网络故障是难以避免的。因此，我们需要在可用性和一致性之间做出选择。如果在分区容错性的前提下，选择保证一致性，那么系统在出现分区的情况下可能会变得不可用；如果在分区容错性的前提下，选择保证可用性，那么系统可能会出现数据不一致的情况。

CAP原理并不是指在所有情况下都只能选择两个特性来满足，而是在设计分布式系统时，需要权衡各种因素，根据应用场景选择适合的CAP组合。比如，某些场景下更需要一致性和可用性，而可以牺牲一些分区容错性；而在另一些场景下，更需要保证分区容错性和可用性，而可以牺牲一些一致性。

== ZK 和 Redis 在CAP上的区别

Zookeeper和Redis都是用于构建分布式系统的工具，但在CAP上有一些区别：

* 一致性：

Zookeeper是一个强一致性的分布式系统工具。它可以确保分布式系统中各个节点之间的数据状态保持一致，即使在网络分区的情况下。Zookeeper通过Paxos算法来保证一致性。
Redis是一个弱一致性的分布式系统工具。Redis的主从复制模型可以保证主节点和从节点之间的数据状态最终一致性，但在数据同步过程中可能会有一定的延迟，因此不能完全保证强一致性。

* 可用性：

Redis是一个高可用性的分布式系统工具。它支持主从复制和Sentinel集群管理工具来确保系统在主节点宕机时自动切换到从节点，并尽快恢复服务。
Zookeeper也是一个高可用性的分布式系统工具。它使用ZAB协议实现主从复制，可以自动选举新的主节点，确保系统在主节点宕机时不会中断服务。

* 分区容错性：

Zookeeper是一个强分区容错性的分布式系统工具。Zookeeper可以在网络分区的情况下继续工作，并保持数据状态的一致性。
Redis是一个弱分区容错性的分布式系统工具。Redis在网络分区时，可能会导致主从节点之间的数据不一致，需要通过人工干预来解决。

综上所述，Zookeeper适合要求强一致性和强分区容错性的分布式系统，Redis适合要求高可用性和数据一致性稍弱的分布式系统。

== Zookeeper的可用性

在Zookeeper中，主节点的选举是通过ZAB（Zookeeper Atomic Broadcast）协议实现的，ZAB协议保证了主节点选举的正确性和一致性。在Zookeeper的选举过程中，所有的节点都可以正常运行并提供服务，只是在选举过程中，某些节点可能会被暂时禁用，直到选举出主节点后重新激活。

具体来说，在Zookeeper的选举过程中，节点会分为两种角色：竞选者和投票者。当竞选者节点发现当前没有主节点时，就会发起选举，请求其他节点投票支持。其他节点会接收到请求并投票，投票结果会返回给竞选者节点，竞选者节点根据投票结果判断是否选举成功。

如果选举成功，选举出的主节点会向其他节点发送通知，其他节点会根据通知更新自己的状态，保证数据的一致性。如果选举失败，竞选者节点会重试选举，直到选举成功。

在整个选举过程中，Zookeeper集群中的节点都可以正常提供服务，只是在选举过程中，某些节点可能会被暂时禁用，直到选举出主节点后重新激活。因此，Zookeeper可以在选出主节点之前继续提供服务。

在Zookeeper中，写入数据的操作需要向集群中的主节点发送请求，因此在选出主节点之前，Zookeeper的客户端只能进行部分读取操作，而不能进行写入操作。

具体来说，在Zookeeper的选举过程中，所有的节点都可以正常运行并提供服务，但只有选举出主节点之后，客户端才能向Zookeeper集群中的主节点发起写入请求，而其他节点只能通过主节点进行数据同步，保证数据的一致性。

因此，如果客户端需要在Zookeeper中写入数据，需要等待选举出主节点之后再进行操作。在等待过程中，客户端可以进行读取操作，以获取Zookeeper集群中的数据状态。

== Zookeeper的强一致性

ZooKeeper通过ZAB协议（ZooKeeper Atomic Broadcast）来实现分布式环境下的强一致性。

ZAB协议是ZooKeeper内部使用的一种类Paxos算法的协议，它通过两阶段提交来保证分布式系统中所有节点的状态都能够保持一致。具体实现流程如下：

Leader选举：ZooKeeper通过ZAB协议选举出一个Leader节点，所有写请求都由Leader节点处理，Leader负责将请求广播给所有节点。

原子广播：Leader将请求以事务的方式发给所有Follower节点，Follower节点接收到请求后会将事务日志记录到本地磁盘上，并向Leader发送确认消息。

事务提交：当Leader接收到大多数Follower节点的确认消息时，就认为该事务已经被提交了，Leader将告诉所有节点该事务已经被提交，并等待其他节点的反馈。

数据同步：一旦Leader通知其他节点该事务已经被提交，其他节点就会按照Leader的指示，从Leader处获取该事务的最新状态，然后更新自己的状态，保证所有节点的状态都能够保持一致。

需要注意的是，ZooKeeper的ZAB协议并不能保证读操作的强一致性。读操作可能会被分发到集群中不同的节点上，因此不同的节点可能会有不同的状态。

ZooKeeper的ZAB协议是为了保证写操作的原子性和顺序性而设计的，并不能保证读操作的强一致性。具体来说，由于读请求可以由任何节点处理，节点之间的数据复制存在一定的延迟，因此在分布式环境下，读操作可能存在数据的“陈旧性”，即读到的数据不是最新的数据。

例如，如果一个客户端在一个节点上写入了一个数据，并立即在另一个节点上进行了读操作，那么由于数据同步的延迟，这个节点可能会返回旧数据，而不是最新的数据。这种情况下，读操作无法保证强一致性。

然而，ZooKeeper提供了一些机制来尽量减小这种“陈旧性”对读操作的影响。例如，客户端可以在读操作中使用watch机制，监控znode的变化，并在发生变化时重新读取数据。此外，ZooKeeper还提供了序列化机制和版本号机制，可以确保数据的顺序和一致性。

总之，尽管ZooKeeper的ZAB协议不能保证读操作的强一致性，但是通过一些机制的使用，可以尽量减小“陈旧性”的影响，从而保证读操作的一致性和可靠性。

ZAB算法论文

http://www.tcs.hut.fi/Studies/T-79.5001/reports/2012-deSouzaMedeiros.pdf

== Raft 算法

https://raft.github.io/

> Raft decomposes consensus into leader election and log propagation phases. After leader election, leader takes all the decisions and communicates to other nodes through ordered logs.

leader election

节点启动时，都以Follower状态开始。等待一段时间后( election timeout ), 变成 Candidate，开始一轮投票（election term）：把票投给自己，并向其他节点请求选票（vote）.接收请求的节点如果在这轮中(term)还没有投票，就把票给发起投票的节点，并且重置自己的（election timeout）。Candidate 获得多数票（majority of votes）后，成为 Leader。Leader 定时发送心跳消息（heartbeat message）给 Follower 以维持自己的leader状态。如果follower在一段时间内没有收到心跳消息，它将变成Candidate，发起一轮新的投票。

Log replication

使用二阶段提交进行

raft算法论文

https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14.pdf

== 二阶段提交（2PC）
二阶段提交还是有几个缺点的：

1、同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。

2、单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）

3、数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。

4、二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。

== 三阶段提交（Three-phase commit 3PC）

三阶段提交有CanCommit、PreCommit、DoCommit三个阶段。

== Gossip protocol


