---
title: "Teambuild"
date: 2024-04-28T13:06:28+08:00
# bookComments: false
# bookSearchExclude: false
---

在评估一个开发人员的能力时，我们经常从两个方面来考察：

## 一是知识的储备 
知识的储备是开发人员的经验，知识储备的考查，可以分为两块：一是知识面的广度，二是知识点的深度。

广度的考查，可以从项目经验入手，考察他在项目中实际应用了哪些技术；还可以从他平时的自我提升中(即使没有真正使用过)，学习了哪些知识。考查的方向也需要和招聘岗位的要求相结合，查看开发人员的知识面和岗位需要的技术栈的契合程度。

深度的考查，则考察他对这些技术的原理的掌握和理解程度。考查他是否明白这些技术的实现细节，以及这些实现背后的思路和理论基础。尤其是对招聘岗位相关的核心业务所需要的技术，更需要重点考查。

## 二是解决问题的能力

解决问题的能力，是开发人员将所掌握的知识灵活应用到实际工作中的能力，主要考查开发人员
- 如何应用所掌握的知识为项目和需求提供良好的解决方案
- 如何通过自己掌握的知识解决系统缺陷。在解决问题的过程中，有时可以看出开发人员遇到新的知识点时的快速学习和应用能力（计算机科学时一门发展非常迅速的学科，因此快速学习能力非常重要）。

招聘过程中，我们需要结合招聘岗位的情况，综合看待这两方面的考查结果，挑选合适的开发人员。
知识储备和能力都突出，且和岗位所需技术栈高度契合的开发人员是最优先的人选。
同时要善于发掘储备稍有欠缺或者和岗位技术栈稍有偏差但能力突出的开发人员。

## 举例

下面举一个对Spring循环依赖的知识点考查的例子：

虽然Spring循环依赖的知识点考查几乎已经成为了面试八股，但如果公司在项目中需要使用Spring框架，对它的考查依然很有价值。

首先，我们可以以开发人员的项目经验或者技能描述为切入点考察开发人员对这块知识的掌握程度
如果开发人员使用过Spring框架，并且知晓Spring给我们提供了一个IoC容器(Inversion of Control container)。那么进一步，考察他是否了解依赖注入（DI, Dependency injection），以及此过程可能会发生循环依赖的情况。

更进一步，考察开发人员是否知道Spring 是在 DefaultSingletonBeanRegistry的实现中，使用三级缓存为Singleton这个默认Scope下的Bean对象构建了一个提前暴露的机制来解决循环依赖问题。以及这个机制在构造型循环依赖问题面前无能为力的事实。然后AbstractBeanFactory继承了DefaultSingletonBeanRegistry，从而使AbstractBeanFactory的所有子类都拥有了处理循环依赖的能力。

其次考察开发人员对Spring 如何使用三级缓存的技术细节是否掌握，以及为何需要使用三级缓存的理解。
比如：
- singletonFactories存放的ObjectFactory类似Supplier，是以备循环依赖时用。如果没有循环依赖发生，Spring不会从singletonFactories缓存中取出ObjectFactory。

- earlySingletonObjects存放了提前暴露的对象实例。在发生循环依赖时，Spring从singletonFactories取出ObjectFactory，获取对象提前暴露出来用于属性注入，同时放入earlySingletonObjects缓存，以备其他循环依赖关系取用（比如A和B循环依赖，A和C也循环依赖）。如果没有AOP代理，ObjectFactory产生原始Bean对象，如果存在AOP代理（存在AbstractAutoProxyCreator），则产生AOP代理对象。

- singletonObjects存放最终的对象实例，对象创建完成，完成属性注入和初始化后注册进来，同时会清除singletonFactories和earlySingletonObjects缓存。在AOP的情况下，如果不存在循环依赖，AOP代理是在init方法应用后处理器时生成的；如果存在循环依赖，后处理器会在自己的缓存中发现对象已经提前包装过，则返回原始Bean，再由Bean工厂取出提前暴露的代理对象作为最终的对象实例返回给调用方。

从上述分析，可见有4种场景：无循环依赖无AOP，无循环依赖有AOP，有循环依赖无AOP，有循环依赖有AOP。因此可以看出三级缓存是为了支持发生类似AOP代理时，最终注入的对象引用（可以理解为指针），不是原始生成的对象引用这类情况。如果引用不变，那么就不需要三级缓存，只需要singletonObjects一个缓存就足够了。

然后结合工作中遇到的问题，比如常见的 @Async 注解导致循环依赖失败，考察解决问题的能力。

AOP自动代理后处理器实现的是SmartInstantiationAwareBeanPostProcessor，可以在getEarlyBeanReference进行提前暴露的处理。但是 @Async 注解的后处理器 AsyncAnnotationBeanPostProcessor 的实现不是SmartInstantiationAwareBeanPostProcessor的子类，没有进行提前暴露的处理。所以会导致注入对象 和 提前暴露对象不一致而最终失败。

我们在设计时，应该尽量避免循环依赖情况的发生。

1. 可维护性: 循环依赖会增加代码的复杂性，使得代码变得难以理解和维护。当一个模块发生变化时，循环依赖可能会导致需要修改多个模块，增加了维护的困难度。
2. 可测试性: 循环依赖可能会使单元测试变得困难。因为要测试一个模块时，你可能需要同时加载其所有依赖的模块，而循环依赖可能导致加载顺序的问题，使得测试变得复杂。
3. 性能问题: 循环依赖可能会导致性能问题，因为模块之间的依赖关系可能会导致不必要的循环调用或资源竞争。
4. 可重用性: 循环依赖可能会限制模块的可重用性。当模块之间紧密耦合时，难以将它们独立地应用于其他项目或环境。

团队建设时，也要考虑梯度。
