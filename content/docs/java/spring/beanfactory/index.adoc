---
title: "BeanFactory"
weight: 1
# bookFlatSection: false
bookToc: true
# bookHidden: false
# bookCollapseSection: false
# bookComments: false
# bookSearchExclude: false
---

= BeanFactory的设计
:imagesdir: images
:toc: 

== 概览
众所周知，spring为我们提供了一个对象工厂，org.springframework.beans.factory.support.DefaultListableBeanFactory是一个默认实现。它的类层次结构图如下：

image::DefaultListableBeanFactory_1.png[DefaultListableBeanFactory]


== BeanFactory接口层次设计
忽略实现部分，可以清晰地看到BeanFactory的接口层次设计：

image::ConfigurableBeanFactory_1.png[] 

BeanFactory作为基础接口提供getBean的能力。三个核心子接口：

- ListableBeanFactory提供了遍历容器中Bean的能力。
- AutowireCapableBeanFactory提供了自动装配的能力。
- ConfiguableBeanFactory（继承自SingletonBeanRegistry和HierarchicalBeanFactory）提供了对BeanFactory配置的能力。

集功能与一身的接口：

- ConfigurableListableBeanFactory，继承了上述三个核心字接口，额外提供了分析和修改BeanDefinition和预加载单例对象的能力。

=== BeanFactory
其中最基础的接口是org.springframework.beans.factory.BeanFactory。

> The root interface for accessing a Spring bean container. This is the basic client view of a bean container; further interfaces such as {@link ListableBeanFactory} and  {@link org.springframework.beans.factory.config.ConfigurableBeanFactory} are available for specific purposes.

接口定义如下图所示：

image::BeanFactory.png[]

它的主要功能有：

1. 按对象名称或者类型获取对象
2. 按类型获取获取ObjectProvider*
3. 按对象名称查询是否存在对象
4. 判断对象是不是单例模式、原型模式
5. 判断对象是不是和给定的类型匹配
6. 按名称获取类型
7. 按名称获取别名列表

这个接口定义了对象工厂的核心功能：通过对象名称获取对象。

从BeanFactory派生出同的接口分别定义不同的功能：

=== ListableBeanFactory

>  Extension of the {@link BeanFactory} interface to be implemented by bean factories that can enumerate all their bean instances, rather than attempting bean lookup by name one by one as requested by clients. BeanFactory implementations that preload all their bean definitions (such as XML-based factories) may implement this interface.
> The methods in this interface will just respect bean definitions of this factory.They will ignore any singleton beans that have been registered by other means like {@link org.springframework.beans.factory.config.ConfigurableBeanFactory}'s {@code registerSingleton} method, with the exception of {@code getBeanNamesOfType} and {@code getBeansOfType} which will check such manually registered singletons too. Of course, BeanFactory's {@code getBean} does allow transparent access to such special beans as well. However, in typical scenarios, all beans will be defined by external bean definitions anyway, so most applications don't need to worry about this differentiation.

接口定义如下：

image::ListableBeanFactory.png[]

主要功能有：

1. 获取BeanDefinition的名称列表和数量
2. 通过类型获取beanNames和一组bean对象
3. 通过注解获取beanNames和一组bean对象
4. 获取bean上对应annotationType的注解

原先BeanFactory只能通过name或者class来获取对象，并不知道自己拥有多少BeanDefinitions（注意，是bean的定义，不是实例化后的bean对象，因为prototype类型的BeanDefinition可以实例化无数对象）。而且，通过name和class都必须能准确定位到具体的bean，如果不能唯一就抛异常。通过扩展，使BeanFactory拥有列举所有beanDefinitions的能力。同时，还支持了通过class获取一组对象的能力（如：通过接口获取容器里实现了该接口的所有对象）。更进一步，还把获取一组对象的能力拓展到注解上。

可见，BeanFactory的所有接口，只关心怎么获取对象。至于是不是通过BeanDefinition来生成对象实例，还是其他方式，都延迟到子类来实现的。体现了spring高内聚的接口设计。

ListableBeanFactory虽然开始关心BeanDefinition，但整个接口设计中，也只是有了BeanDefinition的概念，并不依赖BeanDefinition类。

=== AutowireCapableBeanFactory
> Extension of the {@link org.springframework.beans.factory.BeanFactory} interface to be implemented by bean factories that are capable of autowiring, provided that they want to expose this functionality for existing bean instances.

接口定义如下：

image::AutowireCapableBeanFactory.png[]

主要功能包括：

1. 通过class创建及配置bean实例
2. 对已存在的bean实例进行属性注入，配置或初始化
3. 通过类型或名称获取bean实例，是getBean的变形
4. 处理依赖

这个扩展，使BeanFactory拥有了创建对象和自动装配（或者说“依赖注入”）的能力。本接口配合BeanDefinitionRigestry，BeanFactory就可以完成BeanDefinition的注册，从容器获取Bean对象，在对象还没创建时实例化一个对象并初始化。如果需要支持单例，可以配合SingletonBeanRegistry，将单例对象注册到单例注册器，每次获取对象前先去注册器查找。从而BeanFactory就拥有基本的对象工厂能力了。

所以，在只考虑本级容器的情况下（不考虑父级容），基本的getBean的功能，都由上述几个接口完成了定义。BeanFactory获取Bean的过程中，对bean进行了各种处理，比如类型转换，后置处理等，而这些功能的支持都是通过配置完成的，从而使BeanFactory拥有良好的扩展性。

=== HierarchicalBeanFactory
> Sub-interface implemented by bean factories that can be part of a hierarchy.

接口定义如下：

image::HierarchicalBeanFactory.png[]

功能如下：

1. 获取父级工厂
2. 判断bean是否在本级工厂中

该扩展接口只增加了两个方法，为的是让BeanFactory拥有层级支持的能力。

*到目前为止，上述的三个接口，都是直接继承自BeanFactory接口的。并且所有的方法都是只读的，因此这些接口想要成功获取到对象，当前的beanFactory必须已经拥有了这些对象（BeanInstance）或者对象的定义（BeanDefinition），即BeanFactory已经配置完成。*

=== ConfigurableBeanFactory
对BeanFacotry进行配置的功能，由ConfigurableBeanFactory定义。该接口继承自HierarchicalBeanFactory接口，同时也继承了SingletonBeanRegistry接口。

> Configuration interface to be implemented by most bean factories. Provides facilities to configure a bean factory, in addition to the bean factory client methods in the {@link org.springframework.beans.factory.BeanFactory} interface.

image::ConfigurableBeanFactory.png[]

这个接口提供了对BeanFactory的一系列配置功能（由于对BeanFactory的配置功能非常强大，接口繁多，不一一列举，以下是比较重要的几项）：

==== 1.配置父级容器 setParentBeanFactory

> Set the parent of this bean factory. <p>Note that the parent cannot be changed: It should only be set outside a constructor if it isn't available at the time of factory instantiation.

ConfigurableBeanFactory继承自HierarchicalBeanFactory，所以它也是个支持层级的容器，通过扩展，增加了对父级容器进行设置的功能。
*注意：父级容器一经配置不允许再进行修改。*

==== 2.设置类加载器 setBeanClassLoader

> Set the class loader to use for loading bean classes. Default is the thread context class loader. <p>Note that this class loader will only apply to bean definitions that do not carry a resolved bean class yet. This is the case as of Spring 2.0 by default: Bean definitions only carry bean class names, to be resolved once the factory processes the bean definition.

*默认使用 Thread.currentThread().getContextClassLoader()*

==== 3.配置是否缓存BeanMetadata setCacheBeanMetadata

> Set whether to cache bean metadata such as given bean definitions (in merged fashion) and resolved bean classes. Default is on. <p>Turn this flag off to enable hot-refreshing of bean definition objects and in particular bean classes. If this flag is off, any creation of a bean instance will re-query the bean class loader for newly resolved classes.

*默认是开启状态。*

==== 4.配置表达式处理器 setBeanExpressionResolver

> Specify the resolution strategy for expressions in bean definition values. There is no expression support active in a BeanFactory by default. An ApplicationContext will typically set a standard expression strategy here, supporting "#{...}" expressions in a Unified EL compatible style.

可以通过这个配置支持el表达式。

==== 5.配置类型转换服务 setConversionService

> Specify a Spring 3.0 ConversionService to use for converting property values, as an alternative to JavaBeans PropertyEditors.

从3.0开始以后，spring有了ConversionService。它是转换服务的入口。

> this is the entry point into the convert system. 

==== 6.配置PropertyEditor集合 addPropertyEditorRegistrar、registerCustomEditor 

> Add a PropertyEditorRegistrar to be applied to all bean creation processes. <p>Such a registrar creates new PropertyEditor instances and registers them on the given registry, fresh for each bean creation attempt. This avoids the need for synchronization on custom editors; hence, it is generally preferable to use this method instead of {@link #registerCustomEditor}.

> propertyEditorRegistrar is a interface for strategies that register custom {@link java.beans.PropertyEditor property editors} with a {@link org.springframework.beans.PropertyEditorRegistry property editor registry}. <p>This is particularly useful when you need to use the same set of property editors in several different situations: write a corresponding registrar and reuse that in each case.

==== 7.配置类型转换器TypeConverter setTypeConverter

> Set a custom type converter that this BeanFactory should use for converting bean property values, constructor argument values, etc. <p>This will override the default PropertyEditor mechanism and hence make any custom editors or custom editor registrars irrelevant.

TypeConverter最终还是通过PropertyEditor或者ConversionService进行类型转换。

> Convert the value to the required type (if necessary from a String). Conversions from String to any type will typically use the {@code setAsText} method of the PropertyEditor class, or a Spring Converter in a ConversionService.

==== 8.配置StringValueResolver addEmbeddedValueResolver

> Add a String resolver for embedded values such as annotation attributes.

StringValueResolver 用来处理字符串值，比如占位符等

> Resolve the given String value, for example parsing placeholders.

==== 9.配置BeanPostProcessor addBeanPostProcessor

> Add a new BeanPostProcessor that will get applied to beans created by this factory. To be invoked during factory configuration. <p>Note: Post-processors submitted here will be applied in the order of registration; any ordering semantics expressed through implementing the {@link org.springframework.core.Ordered} interface will be ignored. Note that autodetected post-processors (e.g. as beans in an ApplicationContext) will always be applied after programmatically registered ones.

BeanPostProcessor 在初始化函数回调（比如：afterPropertiesSet或者init-method）的前后提供修改对象的钩子。

>  Factory hook that allows for custom modification of new bean instances

==== 10.注册Scope registerScope

BeanFactory有两个默认的标准Scope：singleton，prototype。通过注册Scope可以进行扩展，比如WebApplicationContext会注册request，session。如果BeanDefinition没有指定Scope,那么在使用的时候，会被指定为singleton。所以很多时候，我们都说spring的bean默认是单例的。

Scope的定义如下：

> Strategy interface used by a {@link ConfigurableBeanFactory}, representing a target scope to hold bean instances in. This allows for extending the BeanFactory's standard scopes {@link ConfigurableBeanFactory#SCOPE_SINGLETON "singleton"} and {@link ConfigurableBeanFactory#SCOPE_PROTOTYPE "prototype"} with custom further scopes, registered for a {@link ConfigurableBeanFactory#registerScope(String, Scope) specific key}.

==== 11.配置Bean的别名 registerAlias

BeanFactory的实现继承了AliasRegistry的实现SimpleAliasRegistry，AliasRegistry中有相同函数。

==== 12.设置Bean是否正在创建中 setCurrentlyInCreation 
==== 13.注册Bean的依赖对象 registerDependentBean 
==== 14.销毁对象 destroyBean、destroyScopedBean、destroySingletons

该接口定义的功能，都是为了配置BeanFactory，一般在创建工厂后

=== ConfigurableListableBeanFactory
继承自ListableBeanFactory, AutowireCapableBeanFactory, ConfigurableBeanFactory。将所有功能集中于一身。还增加了获取BeanDefinition的支持，进行分析、修改。并且提供了预加载单例对象的功能。

> Configuration interface to be implemented by most listable bean factories. In addition to {@link ConfigurableBeanFactory}, it provides facilities to analyze and modify bean definitions, and to pre-instantiate singletons.

image::ConfigurableListableBeanFactory_1.png[]

== BeanFactory的实现
java是单继承的语言，所以DefaultListableBeanFactory的继承链是条单链。可参考下图蓝色实线箭头方向。

image::ConfigurableListableBeanFactory.png[]

在BeanFactory的接口层次设计中，定义了三个注册器：AliasRegistry、BeanDefinitionRegistry和SingletonBeanRegistry，主要功能是暂存数据。这种设计方式也被称为注册者模式，使用一个中央容器对象，将相关对象注册进来，提供全局共享，对象交换的功能。

最上层的两个实现，是对注册的实现。另一个注册器，BeanDefinitionRegistry没有单独的默认实现类，而是由DefaultListableBeanFactory直接实现。

=== AliasRegistry
别名注册器，用于管理别名。一个对象在容器中注册的时候，可以指定别名，也可以专门为一个名称配置一个别名。

> Common interface for managing aliases. Serves as super-interface for {@link org.springframework.beans.factory.support.BeanDefinitionRegistry}.

spring中对别名注册器的实现是SimpleAliasRegistry。它包含一个aliasMap（ConcurrentHashMap），用以存储注册的别名。

image::AliasRegistry.png[]

[别名的使用场景例子](https://www.javacodegeeks.com/2013/12/why-i-like-spring-bean-aliasing.html)

=== SingletonBeanRegistry
用来定义单例对象的注册功能，提供统一管理单例对象的手段。在BeanFactory的实现中，不管是手动注册和通过BeanDifinition生成的单例，都能在这个寄存器中找到。

> Interface that defines a registry for shared bean instances. Can be implemented by {@link org.springframework.beans.factory.BeanFactory} implementations in order to expose their singleton management facility in a uniform manner.

image::SingletonBeanRegistry.png[]

spring中的默认实现是**DefaultSingletonBeanRegistry**，它继承自SimpleAliasRegistry，并实现SingletonBeanRegistry接口。

image::DefaultSingletonBeanRegistry.png[]

> Generic registry for shared bean instances, implementing the{@link org.springframework.beans.factory.config.SingletonBeanRegistry}.Allows for registering singleton instances that should be shared for all callers of the registry, to be obtained via bean name. 
Also supports registration of {@link org.springframework.beans.factory.DisposableBean} instances,(which might or might not correspond to registered singletons),to be destroyed on shutdown of the registry. Dependencies between beans can be registered to enforce an appropriate shutdown order.

该实现类主要用来当作BeanFactory实现的基类，提供对单例对象的管理的支持。因为这是个单例对象注册器，所以核心功能是单例对象的注册和获取，对象的创建工作不属于该类的职责范围。为了支持循环依赖，注册器需要知道正在创建中的单例对象，将未装配完成的对象暴露出来。为了能正确销毁对象，注册器需要知道哪些对象指定了destroy方法，以及对象间的包含和依赖关系。因此它包含了以下几个重要的域：

1. 三个比较重要的缓存，负责存储已注册或者正在创建中的单例对象.
+
- singletonObjects （ConcurrentHashMap）
- singletonFactories （HashMap）
- earlySingletonObjects （ConcurrentHashMap）
+
使用三个缓存主要是为了对循环依赖提供支持，如果没有循环依赖，singletonFactories和earlySingletonObjects是不起作用的。其中singletonFactories是hashMap，而非concurrentHashMap，因为对它的读写全部由synchronized (this.singletonObjects)包裹，因此不需要使用concurrentHashMap。
spring容器有个标志位，是否允许循环依赖:allowCircularReferences。如果此标志开启，当创建一个单例bean的时候,spring会将原始的bean放到 singletonFactories 中。用于可能的循环依赖。
+
[quote, source code of springframework]
"Eagerly caching bean '${beanName}' to allow for resolving potential circular references"
+
singletonFactories是一个键为beanName，值为ObjectFactory的HashMap。可以通过以下方法添加：
+
----
org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#addSingletonFactory
----
+
这个方法是一个protected方法,目前只有在 `org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean` 方法中进行了调用。
`AbstractAutowireCapableBeanFactory` 会将 `getEarlyBeanReference` 函数指针传递给 `ObjectFactory` ，只有发生循环依赖时，才会去调用 `getObject` ，从而调用 `getEarlyBeanReference` 方法。
如果这时在beanFactory中有 `SmartInstantiationAwareBeanPostProcessor` ,会调用这个bpp的 getEarlyBeanReference 方法，否则返回原始的bean。
通过上述处理，就实现了AOP自动代理的对象提前暴露。

2. 一个已注册单例对象名称的集合： 
- registeredSingletons（LinkedHashSet）

3. 一个正在创建中的单例对象的名称集合以及忽略创建检测的对象名称列表：
- singletonsCurrentlyInCreation（SetFromMap）
- inCreationCheckExclusions（SetFromMap）

4. 一组实例对象间的关系映射表：
- containedBeanMap（ConcurrentHashMap）存储 对象名称：包含的对象名称的集合（包含必定依赖）
- dependentBeanMap（ConcurrentHashMap）存储 对象名称：被依赖的对象名称集合（dependent on the key）
- dependenciesForBeanMap（ConcurrentHashMap）存储 对象名称：所依赖对象名称集合（dependencies of the key）

5. 以及一个用于存储关闭容器时需要手动销毁的对象的Map和是否正在销毁单例对象的标志位：
- disposableBeans（LinkedHashMap）
- singletonsCurrentlyInDestruction（boolean）

6. 一个单例创建时被抑制住不往外抛的异常集合
- suppressedExceptions（Set）

DefaultSingletonBeanRegistry还拥有一个抽象子类（abstract class）**FactoryBeanRegistrySupport**，增加了对FactoryBean的注册支持。
内部持有一个factoryBeanObjectCache（ConcurrentHashMap），用于存储由FactoryBeans创建的单例对象（注意：只缓存单例对象）。

附：由于getObjectFromFactoryBean方法中，会判断依赖的bean是否在singletonObjects集合中，不在的话就创建一个。如果有循环依赖FactoryBean生成的对象的场景，需要小心，循环依赖的对象由于还不在singletonObjects集合中，所以会重新创建一个新对象。

实验如下：

image::ExperimentClass.png[]

image::circular-reference.png[]

而ProxyFactoryBean的实现中，getObject会根据是否单例决定是从保存的singletonInstance中取，还是再new一个实例，从而避免上面的问题。
```
@Override
@Nullable
public Object getObject() throws BeansException {
    initializeAdvisorChain();
    if (isSingleton()) {
        return getSingletonInstance();
    }
    else {
        if (this.targetName == null) {
            logger.info("Using non-singleton proxies with singleton targets is often undesirable. " +
                    "Enable prototype proxies by setting the 'targetName' property.");
        }
        return newPrototypeInstance();
    }
}
```

=== BeanDefinitionRegistry
BeanDefinition注册器，用于管理BeanDefinition。整个SpringBeanFactory包中，就只有这个接口定义了关于BeanDefinition的注册功能。所以如果一个BeanFactory的实现，想要支持BeanDefinition的注册，必须实现本接口。同时spring的BeanDifinitionReaders也需要和这个接口配合，将BeanDefinition注册到BeanFactory中。

> Interface for registries that hold bean definitions, for example RootBeanDefinition and ChildBeanDefinition instances. Typically implemented by BeanFactories that internally work with the AbstractBeanDefinition hierarchy.
<p>This is the only interface in Spring's bean factory packages that encapsulates <i>registration</i> of bean definitions. The standard BeanFactory interfaces only cover access to a <i>fully configured factory instance</i>. 
<p>Spring's bean definition readers expect to work on an implementation of this interface. Known implementors within the Spring core are DefaultListableBeanFactory and GenericApplicationContext.

image::BeanDefinitionRegistry.png[]

BeanFactory的实现，主要由三个类来完成：

1. AbstractBeanFactory继承自FactoryBeanRegistrySupport，并实现了ConfigurableBeanFactory，这是BeanFactory最基础的抽象类，实现了BeanFactory的所有配置功能。
2. AbstractAutowireCapableBeanFactory继承自AbstractBeanFactory，并实现了AutowireCapableBeanFactory接口，改类主要提供了通过BeanDifinition创建对象的支持。
3. DefaultListableBeanFactory继承AbstractAutowireCapableBeanFactory，并实现了ConfigurableListableBeanFactory接口和BeanDefinitionRegistry接口（实现了BeanDifinition的注册）。
4. StaticListableBeanFactory是ListableBeanFactory的另一个实现。它只支持注册和获取已经存在的单例对象，不支持从BeanDefinition创建。可以作为BeanFactory的简单实现示例。

image::StaticListableBeanFactory.png[]

=== AbstractBeanFactory
> Abstract base class for {@link org.springframework.beans.factory.BeanFactory} implementations, providing the full capabilities of the {@link org.springframework.beans.factory.config.ConfigurableBeanFactory} SPI.
> This class provides a singleton cache (through its base class  {@link org.springframework.beans.factory.support.DefaultSingletonBeanRegistry}, singleton/prototype determination, {@link org.springframework.beans.factory.FactoryBean} handling, aliases, bean definition merging for child bean definitions, and bean destruction ({@link org.springframework.beans.factory.DisposableBean} interface, custom destroy methods). Furthermore, it can manage a bean factory hierarchy (delegating to the parent in case of an unknown bean), through implementing the {@link org.springframework.beans.factory.HierarchicalBeanFactory} interface.

image::AbstractBeanFactory.png[]

AbstractBeanFactory是BeanFacotry的抽象基类，实现了getBean方法。最主要的方法是doGetBean，它定义了完整的获取一个Bean的过程：

1. 标准化beanName（解析factoryBean的名称和别名，转换成原始的beanName）；
2. 尝试从单例注册器获取对象，如果获取成功，尝试getObjectForBeanInstance（考虑了FactoryBean的情况）并返回；
3. 判断Bean是否存在于本级容器，否则尝试去父容器getBean（如果父容器存在）；
4. 获取BeanDefinition（a merged RootBeanDefinition），获取的时候需要将对应的parent合并进来（BeanDefinition支持parent配置）；为了性能，spring对merge过的BeanDefinition做了缓存，放在mergedBeanDefinitions中；（*具体的BeanDefinition获取由子类实现*）
5. 分别对不同的scope（Singleton，Prototype和注册的scope）进行对象获取。步骤基本相似：before#Creation,createBean,after#Creation,getObjectForBeanInstance。
    - Singleton的获取，交由单例注册器实现，调用的时候传入ObjectFactory告知如何创建bean（主要为了延迟创建bean对象，如果singletonObjects中已经存在，就不需要再创建了。ObjectFactory及其类似JDK8的Supplier）。
    - Prototype因为每次都需要一个新的对象，所以直接进行了对象的创建；
    - 其他注册的scope，交由scope的get借口，也需要给一个ObjectFactory将对象的创建方法传入，给了scope在创建对象时有更大的扩展能力，这点和singleton很相似。而在创建前（before）后（after），用的却是Prototype这个scope的beforePrototypeCreation和afterPrototypeCreation。(*其中具体的对象创建方法createBean的实现则延迟到了子类中*)
6. 尝试进行类型转换（需要的话）并返回。

从上述过程中，可以看到两个非常重要的虚方法：
- getBeanDefinition
- createBean
> The main template methods to be implemented by subclasses are {@link #getBeanDefinition} and {@link #createBean}

[source,mermaid]
----
sequenceDiagram
Application->>AbstractBeanFactory: getBean(name)
AbstractBeanFactory->>AliasRegistry: canonicalName(name)
AliasRegistry->>AbstractBeanFactory: name
AbstractBeanFactory->>SingletonRegistry: getSingleton(name)
SingletonRegistry->>AbstractBeanFactory: sharedInstance
AbstractBeanFactory-->>Application:return if inst is not FactoryBean
AbstractBeanFactory-->>FactoryBeanRegistrySupport: getObjectFromFactoryBean(sharedInstance)
FactoryBeanRegistrySupport-->>AbstractBeanFactory:bean
AbstractBeanFactory-->>Application:bean
AbstractBeanFactory->>BeanDefinitionRegistry:getBeanDefinition(name)
BeanDefinitionRegistry->>AbstractBeanFactory:beanDefinition
AbstractBeanFactory->>AbstractBeanFactory:getMergedBeanDefinition(beanDefinition)
AbstractBeanFactory->>AbstractAutowireCapableBeanFactory:ceateBean(rootBeanDefinition)
AbstractAutowireCapableBeanFactory->>AbstractBeanFactory:instance
AbstractBeanFactory->>FactoryBeanRegistrySupport: getObjectFromFactoryBean(instance)
FactoryBeanRegistrySupport->>AbstractBeanFactory:beanInstance
AbstractBeanFactory->>Application:beanInstance(convertIfNecessary)
----

同时它还实现了ConfigurableBeanFactory，提供对BeanFactory的配置功能。其中包括beanExpresionResolver, conversionService, PropertyEditor, typeConverter, beanPostProcessor等等的配置。默认情况下，这些配置都是空。所以当使用DefaultListableBeanFactory的时候，即使有定义BeanPostProcessor的BeanDefiniton，但是如果不配置到BeanFactory中，它也只是一个普通的Bean。

=== AbstractAutowireCapableBeanFactory
AbstractAutowireCapableBeanFactory完成了bean的创建，属性的注入、装配(包括自动装配）以及初始化。

> Abstract bean factory superclass that implements default bean creation, with the full capabilities specified by the {@link RootBeanDefinition} class.
> Provides bean creation (with constructor resolution), property population, wiring (including autowiring), and initialization. Handles runtime bean references, resolves managed collections, calls initialization methods, etc. Supports autowiring constructors, properties by name, and properties by type.

image::AbstractAutowireCapableBeanFactory.png[]

AbstractAutowireCapableBeanFactory最核心的方法是doCreateBean。在执行doCreateBean方法之前，在createBean方法中会从BeanDefinition中获取bean的class（一般xml配置时，beanClass都是String类型className，需要转换成class）。并且在bean实例化前给InstantiationAwareBeanPostProcessor一个机会，直接返回一个代理Bean对象，而不需要进行真正的对象创建。

doCreateBean创建对象的主要步骤如下：

1. createBeanInstance实例化一个对象。实例化过程中最普遍的方式是通过默认构造函数newInstance一个实例出来。在这之前，会依次尝试从Supplier获取，尝试从FactoryMethod构建。尝试使用SmartInstantiationAwareBeanPostProcessor选取备选构造函数列表，确定构造函数（ConstructorResolver），并使用InstantiationStrategy进行实例化。
2. 给MergedBeanDefinitionPostProcessor一个机会对BeanDefinition进行修改。
3. 在populateBean之前，会将生成的单例实例用ObjectFactory包一层放入singletonFactories缓存中，用来处理单例的循环依赖。（ObjectFactory的getObject方法调用getEarlyBeanReference，其主要功能是遍历调用SmartInstantiationAwareBeanPostProcessor的getEarlyBeanReference方法）。如果使用了aop自动代理，getEarlyBeanReference会将Bean放入earlyProxyReferences中。
4. populateBean填充对象实例的属性。步骤依次为：
    - 在填充之前会调用postProcessAfterInstantiation修改对象状态；
    - 处理自动装配（autowiring bean properties by name or by type）；
    - 提供回调postProcessProperties和postProcessPropertyValues对注入的属性进行处理；
    - 使用BeanDefinitionValueResolver处理BeanDefinition中定义的属性；
    - 通过BeanWrapper的setPropertyValues进行属性设置,如果依赖的是一个ref的bean对象，就会触发getBean。
5. initializeBean初始化bean对象。依次调用：
    - invokeAwareMethods，对BeanNameAware、BeanClassLoaderAware、BeanFactoryAware进行set调用。
    - applyBeanPostProcessorsBeforeInitialization，对象初始化之前的回调。
    - invokeInitMethods，调用init方法。
    - applyBeanPostProcessorsAfterInitialization，对象初始化之后的回调。aop的自动代理正是通过这一步对bean进行处理，返回一个代理对象。如果被循环依赖的bean已经被earlyProxyReferences生成过一次代理对象，在initializeBean的时候将不再进行自动代理，而是返回原始bean。
6. 处理循环依赖的earlySingletonExposure。如果bean提前暴露且initializeBean返回的是原始对象，那么从earlySingletonReference中获取代理对象作为要返回的bean。
7. 尝试注册DisposableBean。

整个createBean的实现中，重点和难点是循环依赖的处理（需要考虑aop的情况）和BeanPostProcessor的应用。

在上述doCreateBean函数执行的步骤3中，创建一个对象(createBeanInstance)之后，会将这个对象包装后放入singletonFactories缓存中：
`addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));`
当循环依赖发生时（假设有a和b两个相互依赖的对象定义），spring在创建a对象时，注入属性b时去创建b对象，而b对象又依赖a。
b在获取a的时候会去SingletonBeanRegistry查找，此时会在singletonFactories中找到a的ObjectFactory，然后通过ObjectFactory的getObject方法调用getEarlyBeanReference。
此方法中，如果有aop代理，会将原始bean放入beanPostProcessor的earlyProxyReferences中，并将生成的代理对象放入earlySingletonObjects中。这样b对象注入的就是一个aop代理对象，此时a已经提前暴露了。
而此时b还在singletonFactories缓存中，并没有提前暴露，所以获取不到b的earlySingletonReference。因此b的exposedObject就是initializeBean之后的代理对象。于是将b添加到singletonObjects中，并移除b的singletonFactories缓存。
完成b对象的获取后，就可以完成a的注入，然后初始化(initializeBean)a对象。因为a对象已经通过getEarlyBeanReference创建过代理，因此不需要再创建：`if (this.earlyProxyReferences.remove(cacheKey) != bean)`，initializeBean方法将返回原始的a。
因为a提前暴露，所以可以找到一个提前暴露的代理对象（earlySingletonReference），因为initializeBean返回的a和原始的a相等，所以设置exposedObject为提前暴露的a的代理对象（earlySingletonReference）。最终完成a的创建，将a添加到singletonObjects中，移除singletonFactories和earlySingletonObjects缓存。

如果没有aop代理，那么exposedObject 和 earlySingletonObjects 都是相同的（都是原始的bean对象）。

=== DefaultListableBeanFactory
> Spring's default implementation of the {@link ConfigurableListableBeanFactory} and {@link BeanDefinitionRegistry} interfaces: a full-fledged bean factory based on bean definition metadata, extensible through post-processors.

其实，在整个BeanFactory类层次中，还有一个基于DefaultListableBeanFactory扩展了XML配置的读取功能的XmlBeanFactory。但在Spring 3.1后标记为@deprecated，转而鼓励使用BeanDefinitionReader 和 BeanDefinitionRegistry。DefaultListableBeanFactory正是BeanDefinitionRegistry的实现。

DefaultListableBeanFactory的典型用法就是先从配置文件中读取所有的BeanDefinition，然后根据名称获取bean对象。

> Typical usage is registering all bean definitions first (possibly read from a bean definition file), before accessing beans. Bean lookup by name is therefore an inexpensive operation in a local bean definition table, operating on pre-resolved bean definition metadata objects.

image::DefaultListableBeanFactory.png[]

DefaultListableBeanFactory拥有三个开关：

- allowBeanDefinitionOverriding
  是否允许beanDefinition覆盖注册，默认为true。

> whether it should be allowed to override bean definitions by registering a different definition with the same name, automatically replacing the former.

- allowEagerClassLoading 
  是否允许beanDefinition在标记为懒加载时，也可以在需要的时候（尤其是getByType的时候）获取beanDefinition的name，默认为true。

> whether the factory is allowed to eagerly load bean classes even for bean definitions that are marked as "lazy-init".

- configurationFrozen
  是否冻结配置。冻结以后，beanDefinitionNames列表（ArrayList）将会缓存到frozenBeanDefinitionNames数组（String[]）中，当getBeanDefinitionNames方法调用时返回给调用者。

> Whether bean definition metadata may be cached for all beans.

DefaultListableBeanFactory的实现有以下几大块：

1. 实现基类AbstractAutowireCapableBeanFactory剩余的没有实现的BeanFactory方法。
主要实现通过类型获取bean对象或者ObjectProvider。
2. 实现ListableBeanFactory接口
3. 实现ConfigurableListableBeanFactory中定义的接口方法
4. 实现BeanDefinitionRegistry接口
beanDefinitionMap就是存放beanDefiniton的一个ConcurrentHashMap，beanDefinitionNames则存放了所有注册了的beanDefiniton的名称。
5. 处理依赖的解决方案实现
主要解决通过类型注入时如何找到一个合适的bean的问题。

== BeanWrapper

> The central interface of Spring's low-level JavaBeans infrastructure.

BeanWrapper 通过`setPropertyValue`和`getPropertyValue`方法设置或者获取JavaBean中的值。BeanWrapper的实现，依赖Java Beans PropertyEditor。

> Spring uses property editors heavily for managing conversion between String values and custom Object types

JDK提供了PropertyEditorSupport来帮助构建property editors。
BeanWrapper本身就是一个PropertyEditorRegistry，其实现继承了PropertyEditorRegistrySupport, 其中维护了一个defaultEditors用于注册Spring定义的editors，同时还有一个customEditors开放给用户注册自定义的editors。
BeanFactory在initBeanWrapper时，会将CustomEditors注册到BeanWrapper中。

image::BeanWrapperImpl.png[]

=== AutomaticBinding

BeanFactory在属性注入的时候，会尝试查找对应的Editor

> Standard JavaBeans infrastructure will automatically discover PropertyEditor classes if they are in the same package as the class they handle. Also, these need to have the same name as that class plus the Editor suffix.

```
try {
    Class<?> editorClass = cl.loadClass(editorName);
    if (editorClass != null) {
        if (!PropertyEditor.class.isAssignableFrom(editorClass)) {
            unknownEditorTypes.add(targetType);
            return null;
        }
        return (PropertyEditor) instantiateClass(editorClass);
    }
    // Misbehaving ClassLoader returned null instead of ClassNotFoundException
    // - fall back to unknown editor type registration below
}
```

=== CustomBinding

自动绑定需要需要JavaBeans 和 Editor 在同一个包里，且Editor的名称为ClassName + Editor。在无法满足这两个要求的情况下，可以使用Custom Property Editor Binding。将自定义的Editor注册到BeanFacotry中。

```
/**
 * Register the given custom property editor for all properties of the
 * given type. To be invoked during factory configuration.
 * <p>Note that this method will register a shared custom editor instance;
 * access to that instance will be synchronized for thread-safety. It is
 * generally preferable to use {@link #addPropertyEditorRegistrar} instead
 * of this method, to avoid for the need for synchronization on custom editors.
 * @param requiredType type of the property
 * @param propertyEditorClass the {@link PropertyEditor} class to register
 */
void registerCustomEditor(Class<?> requiredType, Class<? extends PropertyEditor> propertyEditorClass);
```

https://www.baeldung.com/spring-mvc-custom-property-editor

== Dependency Resolution Process
容器处理依赖的过程如下：

1. 使用配置元数据创建和初始化容器。这些配置元数据描述了容器管理的所有bean。
2. 对于每个bean，它的依赖项以属性、构造函数参数或静态工厂方法参数的形式表示。在bean对象真正创建时，容器会提供这些依赖。
3. 这些依赖，可能是某种类型的值或集合，也可能是对容器中另一个bean的引用。
4. 如果是值，每种类型都有指定的转换器（Editor）将特定格式的配置信息转换成特定的类型。


== BeanDefinitoin

> A BeanDefinition describes a bean instance, which has property values, constructor argument values, and further information supplied by concrete implementations. 

image::AbstractBeanDefinition.png[]

Within the container itself, these bean definitions are represented as BeanDefinition objects, which contain (among other information) the following metadata:

- A package-qualified class name: typically, the actual implementation class of the bean being defined.

- Bean behavioral configuration elements, which state how the bean should behave in the container (scope, lifecycle callbacks, and so forth).

- References to other beans that are needed for the bean to do its work. These references are also called collaborators or dependencies.

- Other configuration settings to set in the newly created object — for example, the size limit of the pool or the number of connections to use in a bean that manages a connection pool.

简单来讲，BeanDefinition包含如下信息：

1. 类，一般就是全类名
2. 行为，如scope(默认单例），bean生命周期回调等
3. 依赖。Spring提倡构造注入，Setter注入主要应该仅用于可以在类中分配合理默认值的可选依赖项。但构造注入在循环依赖的时候会出现先有鸡还是先有蛋的问题，那时可以使用Setter注入避免这个问题。
4. 其他属性

=== Bean Definition Inheritance
Bean Definition可以通过配置parent进行继承，并且可以重写父定义的属性值。

```
<bean id="inheritedTestBean" abstract="true"
		class="org.springframework.beans.TestBean">
	<property name="name" value="parent"/>
	<property name="age" value="1"/>
</bean>

<bean id="inheritsWithDifferentClass"
		class="org.springframework.beans.DerivedTestBean"
		parent="inheritedTestBean" init-method="initialize">
	<property name="name" value="override"/>
	<!-- the age property value of 1 will be inherited from parent -->
</bean>
```
一般情况下，Bean定义都需要指定class。但有一种情况例外，标记abstract为true的BeanDefinition，它只能用作纯模板 bean 定义，充当子定义的父定义。

也正是这个特性，spring在创建bean之前，会通过getMergedBeanDefinition将配置合并，并缓存到mergedBeanDefinitions中(如果cacheBeanMetadata开启的话)。

=== Factory Method

在设计模式中，实例化一个类通常会用到静态工厂方法或者虚拟工厂。
Spring除了支持构造函数实例化一个bean对象外，也支持工厂方法


```
<bean id="exampleBean" class="examples.ExampleBean" factory-method="createInstance">
	<constructor-arg ref="anotherExampleBean"/>
	<constructor-arg ref="yetAnotherBean"/>
	<constructor-arg value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

静态工厂方法的参数由 `<constructor-arg/>` 元素提供。并且静态工厂方法的返回类型，是方法返回的对象的类型，不需要和包含该方法的类一致。

> Arguments to the static factory method are supplied by <constructor-arg/> elements, exactly the same as if a constructor had actually been used.

```
public class ExampleBean {

	// a private constructor
	private ExampleBean(...) {
		...
	}

	// a static factory method; the arguments to this method can be
	// considered the dependencies of the bean that is returned,
	// regardless of how those arguments are actually used.
	public static ExampleBean createInstance (
		AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

		ExampleBean eb = new ExampleBean (...);
		// some other operations...
		return eb;
	}
}
```

== Bean Scopes

The Spring Framework 支持6种Scope，其中singleton和prototype是两个内建的scope，其他4个是在web环境使用的。Spring也支持注册自定义Scope。

[[beans-factory-scopes-tbl]]
.Bean scopes
[cols="20%,80%"]
|===
| Scope| Description

| singleton
| (Default) Scopes a single bean definition to a single object instance for each Spring IoC
  container.

| prototype
| Scopes a single bean definition to any number of object instances.

| request
| Scopes a single bean definition to the lifecycle of a single HTTP request. That is,
  each HTTP request has its own instance of a bean created off the back of a single bean
  definition. Only valid in the context of a web-aware Spring `ApplicationContext`.

| session
| Scopes a single bean definition to the lifecycle of an HTTP `Session`. Only valid in
  the context of a web-aware Spring `ApplicationContext`.

| application
| Scopes a single bean definition to the lifecycle of a `ServletContext`. Only valid in
  the context of a web-aware Spring `ApplicationContext`.

| websocket
| Scopes a single bean definition to the lifecycle of a `WebSocket`. Only valid in
  the context of a web-aware Spring `ApplicationContext`.
|===

NOTE: A thread scope is available but is not registered by default. 

我们在AbstractBeanFactory的doGetBean方法中可以看到如下代码：

```
// Create bean instance.
if (mbd.isSingleton()) {
    ...
}

else if (mbd.isPrototype()) {
    // It's a prototype -> create a new instance.
    ...
}

else {
    String scopeName = mbd.getScope();
    if (!StringUtils.hasLength(scopeName)) {
        throw new IllegalStateException("No scope name defined for bean '" + beanName + "'");
    }
    Scope scope = this.scopes.get(scopeName);
    if (scope == null) {
        throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
    }
    ...
}
```

image::Scope.png[]

从代码可以看出，Spring是不允许重写 singleton and prototype 这两个内建的scopes的。

=== Singleton Beans with Prototype-bean Dependencies
当一个单例bean对象依赖一个原型bean对象时，一定要清楚原型实例在第一次初始化时就已经确定好了。如果希望单例对象每次都能获取一个新的原型实例，不能使用依赖注入（dependency-inject ），可以考虑使用 Method Injection.

=== Scoped Beans as Dependencies

如果您想将 HTTP 请求作用域的 bean 注入到另一个寿命较长作用域的 bean 中，则可以选择注入 AOP 代理来代替作用域 bean。

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop
		https://www.springframework.org/schema/aop/spring-aop.xsd">

	<!-- an HTTP Session-scoped bean exposed as a proxy -->
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session">
		<!-- instructs the container to proxy the surrounding bean -->
		<aop:scoped-proxy/>
	</bean>

	<!-- a singleton-scoped bean injected with a proxy to the above bean -->
	<bean id="userService" class="com.something.SimpleUserService">
		<!-- a reference to the proxied userPreferences bean -->
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
</beans>
```

== Lifecycle

可以在初始化和销毁bean时定义回调函数与Spring对bean生命周期的管理进行交互。

从Spring的init过程可以看到,
首先Spring会应用BeanPostProcessors, 调用postProcessBeforeInitialization
(Spring的CommonAnnotationBeanPostProcessor负责处理PostConstruct 和 PreDestroy这两个注解)
然后调用initMethods，执行InitializingBean接口的afterPropertiesSet方法，以及在beanDefinition中定义的init方法。

```
Object wrappedBean = bean;
    if (mbd == null || !mbd.isSynthetic()) {
    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
}

    try {
    invokeInitMethods(beanName, wrappedBean, mbd);
}
    catch (Throwable ex) {
    throw new BeanCreationException(
            (mbd != null ? mbd.getResourceDescription() : null),
            beanName, "Invocation of init method failed", ex);
}
```

所以，如果同时使用多种回调配置(并使用不同的方法,如果方法相同之会执行一次)，那么执行顺序如下：

=== Initialization Callbacks

1. Methods annotated with @PostConstruct

2. afterPropertiesSet() as defined by the InitializingBean callback interface

3. A custom configured init() method

=== Destruction Callbacks
销毁的过程顺序类似

1. Methods annotated with @PreDestroy

2. destroy() as defined by the DisposableBean callback interface

3. A custom configured destroy() method

=== CommonAnnotationBeanPostProcessor

CommonAnnotationBeanPostProcessor 是一个BeanPostProcessor，支持开箱即用的常见 Java 注释，特别是 javax.annotation 包中的 JSR-250 注释。包含： PostConstruct 和 PreDestro。同时，它也包含对 @Resource注解的处理。

image::CommonAnnotationBeanPostProcessor.png[]

处理@Resource注解虽然和 @AutoWire 和 @Value 注解类似，但是后两者属于Spring的扩展，所以Spring使用AutowiredAnnotationBeanPostProcessor这个BeanPostProcessor进行处理。这体现了spring在设计上的高内聚。
两者还有一个很大的区别： @Resource 是基于名称注入的 而 @AutoWire 则是基于类型注入的。

== BeanDefinitionRegistry 

DefaultListableBeanFactory是一个BeanDefinitionRegistry，BeanDefinitionRegistry 是 Spring 的 bean 工厂包中唯一封装 BeanDefinition 注册的接口。也就是说 BeanDefinition 只能通过这个接口注册到BeanFactory中。
在ApplicationContext中，可以通过`getBeanFactory()`方法获取到DefaultListableBeanFactory，从而注册用户在容器外部创建的对象。但通常不需要这么做。如果真的需求，那么务必尽早注册。

> Bean metadata and manually supplied singleton instances need to be registered as early as possible, in order for the container to properly reason about them during autowiring and other introspection steps. 


=== BeanDefinitionReader 

Spring提供了一个BeanDefinition读取器的简单接口:BeanDefinitionReader。
比如：XmlBeanDefinitionReader 就是Spring读取XML bean definitions 的 BeanDefinitionReader 实现。

但并不是所有的读取器都要实现这个接口，它是一个想要遵循标准命名约定的建议。
比如：ConfigurationClassBeanDefinitionReader 就是从 ConfigurationClass instances 集合中读取bean definitions并注册到BeanDefinitionRegistry中，但并没有实现BeanDefinitionReader接口。

> Note that a bean definition reader does not have to implement this interface. It only serves as a suggestion for bean definition readers that want to follow standard naming conventions.

==== XmlBeanDefinitionReader

image::XmlBeanDefinitionReader.png[]

XML是Spring定义配置元数据的传统格式。比如在传统的使用web.xml描述文件进行配置的Spring web应用中，DispatcherServlet 会持有一个WebApplicationContext，它的默认实现就是XmlWebApplicationContext。这个wac就是通过XmlBeanDefinitionReader读取xml文件注册定义的BeanDefinitions。

每次读取一个resource，reader都会create一个XmlReaderContext，其中包括要解析的 Resource， 以及 ProblemReporter、ReaderEventListener、SourceExtractor、XmlBeanDefinitionReader 和 NamespaceHandlerResolver。

spring默认的namespace(以下简称ns)为：`http://www.springframework.org/schema/beans`
其他ns都需要通过NamespaceHandlerResolver获取到对应的NamespaceHandler。
NamespaceHandlerResolver 会从 META-INF/spring.handlers 读取配置，并根据配置的handler-class初始化handler对象，把 namespace 和 对应的 handler 对象 放到 handlerMappings 中。NamespaceHandlerResolver 由 BeanDefinitionReader 创建，并当作构造参数传递给 XmlReaderContext。
解析的真正工作是交给 BeanDefinitionParserDelegate 实现的。构建delegate对象的时候，需要XmlReaderContext对象作为构造参数。

每个 handler 会持有一组 BeanDefinitionParser，以 ContextNamespaceHandler 为例， 它在init时注册了8个parser：

- PropertyPlaceholderBeanDefinitionParser
- PropertyOverrideBeanDefinitionParser
- AnnotationConfigBeanDefinitionParser
- ComponentScanBeanDefinitionParser
- LoadTimeWeaverBeanDefinitionParser
- SpringConfiguredBeanDefinitionParser
- MBeanExportBeanDefinitionParser
- MBeanServerBeanDefinitionParser

image::ContextNamespaceHandler.png[]

=== ComponentScanBeanDefinitionParser

除了使用xml配置Beans，我们还可以使用注解进行配置。
我们需要在xml配置中，配置 `context:component-scan` ，spring会先通过 `context` 前缀确定 namespace，然后通过 NamespaceHandlerResolver 找到 namespace 对应的 NamespaceHandler。`context` 对应的 handler 是 `ContextNamespaceHandler`（继承自`NamespaceHandlerSupport`）, NamespaceHandlerSupport 的解析(parse)，又会委托给对应的 parser 去进行解析。`component-scan` 对应的parser 就是 `ComponentScanBeanDefinitionParser`。

parser在进行解析(parse)时，会创建一个 ClassPathBeanDefinitionScanner

image::ClassPathBeanDefinitionScanner.png[]

通过 scaner 扫描出来的的 beanDefinition 以 `ScannedGenericBeanDefinition` 为实现类被注册到
BeanDefinitionRegistry。这个完成BeanDefinition注册的实现，就没有实现BeanDefinitionReader。

#### ConfigurationClassPostProcessor

application在refresh的过程中，会调用 invokeBeanFactoryPostProcessors 来对 beanFactory进行后处理。后处理过程委托给 PostProcessorRegistrationDelegate 进行实现。

Delegate 会优先找出 BeanDefinitionRegistryPostProcessor 进行后处理，其中 `ConfigurationClassPostProcessor` 是配置了component-scan 后 默认被注册到register中的一个BeanDefinitionRegistryPostProcessor，

> This post processor is priority-ordered as it is important that any @Bean methods declared in @Configuration classes have their corresponding bean definitions registered before any other BeanFactoryPostProcessor executes.

当配置了 <context:annotation-config/> or <context:component-scan/> 后， 默认就会注册 名称为 “org.springframework.context.annotation.internalConfigurationAnnotationProcessor”，class 为 ConfigurationClassPostProcessor 的 beanDefinition。


> `<context:annotation-config> is used to activate annotations in beans already registered in the application context (no matter if they were defined with XML or by package scanning).
<context:component-scan> can also do what <context:annotation-config> does but <context:component-scan> also scans packages to find and register beans within the application context.`

`<context:annotation-config/>` 和 `<context:component-scan/>` 的区别在于component-scan会多一步扫描包来发现bean。

具体可参见：
https://stackoverflow.com/questions/7414794/difference-between-contextannotation-config-and-contextcomponent-scan

#### ConfigurationClassParser

beanDefinition加载完毕后，通过 scaner 扫描出来的的 beanDefinition 以 `ScannedGenericBeanDefinition` 为实现类(实现了 `AnnotatedBeanDefinition` 接口 )被注册到
BeanDefinitionRegistry。

image::ScannedGenericBeanDefinition.png[]

ConfigurationClassPostProcessor 会找出 注册的 `AnnotatedBeanDefinition`，然后创建ConfigurationClassParser 对 @Configuration 的class 进行解析（@Component也行）。

parser首先通过beanDefintion获取metadata和beanName构造一个ConfigurationClass对象，然后对这个ConfigurationClass对象进行解析。(因此这个 parser 是 ConfigurationClassParser， 用来解析 ConfigurationClass 的。)

#### ConfigurationClassBeanDefinitionReader

解析完 ConfigurationClass， ConfigurationClassPostProcessor 会构建 ConfigurationClassBeanDefinitionReader 读取 ConfigurationClass 中的配置，然后注册 ConfigurationClassBeanDefinition 到 registry 中。


