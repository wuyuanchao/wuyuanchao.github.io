---
title: "BeanDefinition"
weight: 1
# bookFlatSection: false
# bookToc: true
# bookHidden: false
# bookCollapseSection: false
# bookComments: false
# bookSearchExclude: false
---

= BeanDefinition
:toc:
:imagesdir: images

== BeanDefinitoin

> A BeanDefinition describes a bean instance, which has property values, constructor argument values, and further information supplied by concrete implementations. 

image::AbstractBeanDefinition.png[]

Within the container itself, these bean definitions are represented as BeanDefinition objects, which contain (among other information) the following metadata:

- A package-qualified class name: typically, the actual implementation class of the bean being defined.

- Bean behavioral configuration elements, which state how the bean should behave in the container (scope, lifecycle callbacks, and so forth).

- References to other beans that are needed for the bean to do its work. These references are also called collaborators or dependencies.

- Other configuration settings to set in the newly created object — for example, the size limit of the pool or the number of connections to use in a bean that manages a connection pool.

== BeanDefinitionRegistry 

DefaultListableBeanFactory是一个BeanDefinitionRegistry，BeanDefinitionRegistry 是 Spring 的 bean 工厂包中唯一封装 BeanDefinition 注册的接口。也就是说 BeanDefinition 只能通过这个接口注册到BeanFactory中。

Spring提供了一个BeanDefinition读取器的简单接口:BeanDefinitionReader。
比如：XmlBeanDefinitionReader 就是Spring读取XML bean definitions 的 BeanDefinitionReader 实现。

但并不是所有的读取器都要实现这个接口，它是一个想要遵循标准命名约定的建议。
比如：ConfigurationClassBeanDefinitionReader 就是从 ConfigurationClass instances 集合中读取bean definitions并注册到BeanDefinitionRegistry中，但并没有实现BeanDefinitionReader接口。

> Note that a bean definition reader does not have to implement this interface. It only serves as a suggestion for bean definition readers that want to follow standard naming conventions.

=== XmlBeanDefinitionReader

image::XmlBeanDefinitionReader.png[]

XML是Spring定义配置元数据的传统格式。比如在传统的使用web.xml描述文件进行配置的Spring web应用中，DispatcherServlet 会持有一个WebApplicationContext，它的默认实现就是XmlWebApplicationContext。这个wac就是通过XmlBeanDefinitionReader读取xml文件注册定义的BeanDefinitions。

每次读取一个resource，reader都会create一个XmlReaderContext，其中包括要解析的 Resource， 以及 ProblemReporter、ReaderEventListener、SourceExtractor、XmlBeanDefinitionReader 和 NamespaceHandlerResolver。

spring默认的namespace(以下简称ns)为：`http://www.springframework.org/schema/beans`
其他ns都需要通过NamespaceHandlerResolver获取到对应的NamespaceHandler。
NamespaceHandlerResolver 会从 META-INF/spring.handlers 读取配置，并根据配置的handler-class初始化handler对象，把 namespace 和 对应的 handler 对象 放到 handlerMappings 中。NamespaceHandlerResolver 由 BeanDefinitionReader 创建，并当作构造参数传递给 XmlReaderContext。
解析的真正工作是交给 BeanDefinitionParserDelegate 实现的。构建delegate对象的时候，需要XmlReaderContext对象作为构造参数。

每个 handler 会持有一组 BeanDefinitionParser，以 ContextNamespaceHandler 为例， 它在init时注册了8个parser：

- PropertyPlaceholderBeanDefinitionParser
- PropertyOverrideBeanDefinitionParser
- AnnotationConfigBeanDefinitionParser
- ComponentScanBeanDefinitionParser
- LoadTimeWeaverBeanDefinitionParser
- SpringConfiguredBeanDefinitionParser
- MBeanExportBeanDefinitionParser
- MBeanServerBeanDefinitionParser

image::ContextNamespaceHandler.png[]

=== ComponentScanBeanDefinitionParser

除了使用xml配置Beans，我们还可以使用注解进行配置。
我们需要在xml配置中，配置 `context:component-scan` ，spring会先通过 `context` 前缀确定 namespace，然后通过 NamespaceHandlerResolver 找到 namespace 对应的 NamespaceHandler。`context` 对应的 handler 是 `ContextNamespaceHandler`（继承自`NamespaceHandlerSupport`）, NamespaceHandlerSupport 的解析(parse)，又会委托给对应的 parser 去进行解析。`component-scan` 对应的parser 就是 `ComponentScanBeanDefinitionParser`。

parser在进行解析(parse)时，会创建一个 ClassPathBeanDefinitionScanner

image::ClassPathBeanDefinitionScanner.png[]

通过 scaner 扫描出来的的 beanDefinition 以 `ScannedGenericBeanDefinition` 为实现类被注册到
BeanDefinitionRegistry。这个完成BeanDefinition注册的实现，就没有实现BeanDefinitionReader。

#### ConfigurationClassPostProcessor

application在refresh的过程中，会调用 invokeBeanFactoryPostProcessors 来对 beanFactory进行后处理。后处理过程委托给 PostProcessorRegistrationDelegate 进行实现。

Delegate 会优先找出 BeanDefinitionRegistryPostProcessor 进行后处理，其中 `ConfigurationClassPostProcessor` 是配置了component-scan 后 默认被注册到register中的一个BeanDefinitionRegistryPostProcessor，

> This post processor is priority-ordered as it is important that any @Bean methods declared in @Configuration classes have their corresponding bean definitions registered before any other BeanFactoryPostProcessor executes.

当配置了 <context:annotation-config/> or <context:component-scan/> 后， 默认就会注册 名称为 “org.springframework.context.annotation.internalConfigurationAnnotationProcessor”，class 为 ConfigurationClassPostProcessor 的 beanDefinition。


> `<context:annotation-config> is used to activate annotations in beans already registered in the application context (no matter if they were defined with XML or by package scanning).
<context:component-scan> can also do what <context:annotation-config> does but <context:component-scan> also scans packages to find and register beans within the application context.`

`<context:annotation-config/>` 和 `<context:component-scan/>` 的区别在于component-scan会多一步扫描包来发现bean。

具体可参见：
https://stackoverflow.com/questions/7414794/difference-between-contextannotation-config-and-contextcomponent-scan

#### ConfigurationClassParser

beanDefinition加载完毕后，通过 scaner 扫描出来的的 beanDefinition 以 `ScannedGenericBeanDefinition` 为实现类(实现了 `AnnotatedBeanDefinition` 接口 )被注册到
BeanDefinitionRegistry。

image::ScannedGenericBeanDefinition.png[]

ConfigurationClassPostProcessor 会找出 注册的 `AnnotatedBeanDefinition`，然后创建ConfigurationClassParser 对 @Configuration 的class 进行解析（@Component也行）。

parser首先通过beanDefintion获取metadata和beanName构造一个ConfigurationClass对象，然后对这个ConfigurationClass对象进行解析。(因此这个 parser 是 ConfigurationClassParser， 用来解析 ConfigurationClass 的。)

#### ConfigurationClassBeanDefinitionReader

解析完 ConfigurationClass， ConfigurationClassPostProcessor 会构建 ConfigurationClassBeanDefinitionReader 读取 ConfigurationClass 中的配置，然后注册 ConfigurationClassBeanDefinition 到 registry 中。
