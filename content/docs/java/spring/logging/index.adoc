---
title: "Spring Logging System"
weight: 1
# bookFlatSection: false
bookToc: true
# bookHidden: false
# bookCollapseSection: false
# bookComments: false
# bookSearchExclude: false
---

== Spring Logging System
:imagesdir: images
:toc: 

> Spring Boot uses Commons Logging for all internal logging but leaves the underlying log implementation open. Default configurations are provided for Java Util Logging, Log4j2, and Logback. In each case, loggers are pre-configured to use console output with optional file output also available.
>
> By default, if you use the starters, Logback is used for logging. Appropriate Logback routing is also included to ensure that dependent libraries that use Java Util Logging, Commons Logging, Log4J, or SLF4J all work correctly.

https://docs.spring.io/spring-boot/reference/features/logging.html

image::LoggingSystem.png[]

== 加载
Spring启动时，会加载 Spring Boot 在 spring.factories 中配置的 ApplicationListeners：

～/.m2/repository/org/springframework/boot/spring-boot/3.5.5/spring-boot-3.5.5.jar!/META-INF/spring.factories

[, Shell]
----
# Application Listeners
org.springframework.context.ApplicationListener=\
org.springframework.boot.ClearCachesApplicationListener,\
org.springframework.boot.builder.ParentContextCloserApplicationListener,\
org.springframework.boot.context.FileEncodingApplicationListener,\
org.springframework.boot.context.config.AnsiOutputApplicationListener,\
org.springframework.boot.context.logging.LoggingApplicationListener,\
org.springframework.boot.env.EnvironmentPostProcessorApplicationListener
----

其中 LoggingApplicationListener 就是其中一员。

LoggingApplicationListener 在接收到 ApplicationStartingEvent（启动） 事件时，会调用 LoggingSystem的get方法（静态）加载具体的 LoggingSystem，而真正的加载工作最终委托给 DelegatingLoggingSystemFactory。

[,Java]
----
private static final LoggingSystemFactory SYSTEM_FACTORY = LoggingSystemFactory.fromSpringFactories();

public static LoggingSystem get(ClassLoader classLoader) {
    String loggingSystemClassName = System.getProperty(SYSTEM_PROPERTY);
    if (StringUtils.hasLength(loggingSystemClassName)) {
        if (NONE.equals(loggingSystemClassName)) {
            return new NoOpLoggingSystem();
        }
        return get(classLoader, loggingSystemClassName);
    }
    LoggingSystem loggingSystem = SYSTEM_FACTORY.getLoggingSystem(classLoader);
    Assert.state(loggingSystem != null, "No suitable logging system located");
    return loggingSystem;
}
----

springboot的LoggingSystemFactory配置如下：

[,Shell]
----
# Logging Systems
org.springframework.boot.logging.LoggingSystemFactory=\
org.springframework.boot.logging.java.JavaLoggingSystem$Factory,\
org.springframework.boot.logging.log4j2.Log4J2LoggingSystem$Factory,\
org.springframework.boot.logging.logback.LogbackLoggingSystem$Factory
----

这三个Factory都有@Order注解，分别是：

- LogbackLoggingSystem 
`@Order(Ordered.HIGHEST_PRECEDENCE + 1024)`

- Log4J2LoggingSystem 
`@Order(0)`

- JavaLoggingSystem
`@Order(Ordered.LOWEST_PRECEDENCE - 1024)`

以优先级最高的 LogbackLoggingSystem 为例，判断 `qos.logback.classic.LoggerContext` 类是否存在，存在则创建 LogbackLoggingSystem 实例。
[,Java]
----
@Order(Ordered.HIGHEST_PRECEDENCE + 1024)
public static class Factory implements LoggingSystemFactory {

    private static final boolean PRESENT = ClassUtils.isPresent("ch.qos.logback.classic.LoggerContext",
            Factory.class.getClassLoader());

    @Override
    public LoggingSystem getLoggingSystem(ClassLoader classLoader) {
        if (PRESENT) {
            return new LogbackLoggingSystem(classLoader);
        }
        return null;
    }

}
----

`qos.logback.classic.LoggerContext` 类则是由 `spring-boot-starter-logging` 依赖传递而来。

== 初始化

确定好具体的 LoggingSystem 后就要开始初始化工作。在处理 ApplicationStartingEvent 时，Listener 会调用 LoggingSystem 的 beforeInitialize 方法进行一些初始化前的准备工作。

真正的初始化工作在 ApplicationEnvironmentPreparedEvent 事件处理中完成。Spring会先去查找环境变量中有没有日志	

----
public static final String FILE_NAME_PROPERTY = "logging.file.name";
public static final String FILE_PATH_PROPERTY = "logging.file.path";
----

然后查找配置文件， LoggingSystem 通过抽象方法 `getStandardConfigLocations` 让子类提供标准配置路径，以logback为例：

----
@Override
protected String[] getStandardConfigLocations() {
    return new String[] { "logback-test.groovy", "logback-test.xml", "logback.groovy", "logback.xml" };
}
----

并且会尝试添加 `-spring` 后缀后的配置。所以我们的 logback-spring.xml才能被加载。

[,Java]
----
protected String[] getSpringConfigLocations() {
    String[] locations = getStandardConfigLocations();
    for (int i = 0; i < locations.length; i++) {
        String extension = StringUtils.getFilenameExtension(locations[i]);
        locations[i] = locations[i].substring(0, locations[i].length() - extension.length() - 1) + "-spring."
                + extension;
    }
    return locations;
}
----

如果没有任何配置文件，AbstractLoggingSystem 抽象了 `loadDefaults` 方法，由子类实现如何进行默认加载。
----
protected abstract void loadDefaults(LoggingInitializationContext initializationContext, LogFile logFile);
----

LogbackLoggingSystem 会启动一个默认的 LoggerContext。